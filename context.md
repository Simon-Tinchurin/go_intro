# Контекст

Package context defines the Context type, which carries deadlines, cancellation signals, and other request-scoped values across API boundaties and between processes.

**Контекст** - объект, предназначен для того, чтобы иметь возможность отменить извне выполнение потенциально долгой операции. 
С помощью контекста можно хранить и передавать информацию между функциями и методами внутри программы.
* Внешний контроль над потенциально долгими операциями
* Передача информации по флоу программы

### Способы отмены долгих операций с помощью контекста:
* Явный сигнал отмены - ```context.WithCancel()```
* Истечение промежутка времени - ```context.WithTimeout()```
* По наступлению временной отметки - ```context.WithDeadline()```

### Пример - Запрос по сети

```
ctx, cancel := context.WithTimeout(context.Background(), 15 * time.Second)
// гарантирует что после выхода из функции goroutine контекст будет отменен
defer cancel()

req, err := http.NewRequestWithContext(ctx, http.MethodGet, "https://example.com", nil)
if err != nil {
    return nil, fmt.Errorf("failed to create request with ctx: %w", err)
}

res, err := http.DefaultClient.Do(req)
if err != nil {
    return nil, fmt.Errorf("failed to perform http request: %w", err)
}
return res, nil
```

```context.Background()``` - контекст заглушка, используется как самый верхний родитель для всех контекстов в иерархии

```context.TODO()``` - тоже заглушка, используется когда не определились какой тип контекста нужно использовать. По сути одно и то же, разница семантическая.
### Передача данных в контекст - антипаттерн, не использовать.
Пораждает неявный и ненадежный контракт между компанентами приложения.

```ctx := context.WithValue(context.Background(), "key", "value")```
### Исключение - когда нужно предоставить компоненты из внешней библиотеки в свою реализацию интерфейска, которую нельзя изменить

### Когда использовать контекст:
* Метод ходит по сети
* Горутина может долго висеть

### Советы:
* Всегда передавать контекст первым аргументом - общепринятое соглашение
* Передавать контекст только в функции и методы
* Использовать ```context.WithValue()``` только в крайних случаях, в 99.9% случаев хватает args/kwargs
* ```context.Background()``` должен использоваться только как верхниий родительский контекст, т.к. он является заглушкой и не предоставляет средств контроля
* Помнить про функции отмены контекста
* Передавать только контекст без функции отмены. Контроль за завершением контекста должен оставаться на вызывающей стороне